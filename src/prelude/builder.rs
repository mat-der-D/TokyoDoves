use std::str::FromStr;

use strum::IntoEnumIterator;

use crate::error;
use crate::prelude::{
    board::{
        main::Board,
        mask::MaskViewer,
        position::{ColorDovePositions, DovePositions},
    },
    pieces::{color_to_index, dove_to_index, try_char_to_color_dove, Color, Dove},
};

/// A builder of [`Board`].
///
/// This struct provides a variety of ways to construct [`Board`].
/// It creates [`Board`] in two steps:
/// 1. Create a [`BoardBuilder`] object. Edit it if necessary.
/// 2. Call a method to build [`Board`].
///
/// In the first step, all information required to create [`Board`]
/// has to be prepared. The following methods are supported to create [`BoardBuilder`]:
/// - [`new`](`Self::new`)<br>
///     ... creates the board at the begnining
/// - [`empty`](`Self::empty`)<br>
///     ... creates the board without any doves
/// - [`try_from_4x4_matrix`](`Self::try_from_4x4_matrix`)<br>
///     ... creates based on 4x4 matrix (array of array)
/// - [`from_u16_bits`](`Self::from_u16_bits`)<br>
///     ... creates based on `u16` values representing positions of doves
/// - [`from_u64_bits`](`Self::from_u64_bits`)<br>
///     ... creates based on `u64` values representing positions of doves
///
/// The following methods are for editing [`BoardBuilder`]:
/// - [`put_dove`](`Self::put_dove`)<br>
///     ... puts a dove on a position
/// - [`remove_dove`](`Self::remove_dove`)<br>
///     ... removes a dove at a position
/// - [`trim_outside_4x4`](`Self::trim_outside_4x4`)<br>
///     ... removes all doves outside 4x4 region
///
/// In the second step, [`BoardBuilder`] creates [`Board`] by one of the following methods:
/// - [`build`](`Self::build`)<br>
///     ... creates [`Board`] with checking the board to be created are legal.
///     It needs unwrapping to extract [`Board`].
/// - [`build_unchecked`](`Self::build_unchecked`)<br>
///     ... creates [`Board`] without legality check.
///
/// # Examples
/// The board at the beginning:
/// ```rust
/// use tokyodoves::{Board, BoardBuilder};
///
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// let board0 = Board::new();
/// let board1 = BoardBuilder::new().build()?;
/// let board2 = BoardBuilder::default().build()?;
/// assert_eq!(board0, board1);
/// assert_eq!(board0, board2);
/// # Ok(())
/// # }
/// ```
/// Create 4x4 (or `[[Option<(Color, Dove)>; 4]; 4]`).
/// ```rust
/// use tokyodoves::{BoardBuilder, Color, Dove};
///
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// use Color::*;
/// use Dove::*;
/// let matrix = [
///     [Some((Green, B)), None, None, None],
///     [Some((Red, B)), None, None, None],
///     [None, Some((Red, A)), Some((Green, H)), None],
///     [None, None, None, None],
/// ];
/// let board = BoardBuilder::try_from(matrix)?.build()?;
/// # Ok(())
/// # }
/// ```
/// The `u64` expression generated by the [`to_u64`](`Board::to_u64`) method
/// is also a seed of [`BoardBuilder`].
/// ```rust
/// use tokyodoves::BoardBuilder;
///
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// let hash = 864761497199312896u64; // Board at the begining
/// let board = BoardBuilder::from(hash).build()?;
/// # Ok(())
/// # }
/// ```
/// A string expression is also supported. The method requires to use [`std::str::FromStr`].
/// ```rust
/// use std::str::FromStr;
/// use tokyodoves::BoardBuilder;
///
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// let board_str = "b   ;B   ; Ah ;    ";
/// // Short-cut version:
/// // let board_str = "b;B; Ah";
/// let board = BoardBuilder::from_str(board_str)?.build()?;
/// # Ok(())
/// # }
/// ```
///
/// ```rust
/// use tokyodoves::BoardBuilder;
///
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// let board = BoardBuilder::new().build_unchecked();
/// # Ok(())
/// # }
/// ```
#[derive(Debug, Clone, Copy)]
pub struct BoardBuilder {
    positions: [[u64; 6]; 2],
}

impl Default for BoardBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl BoardBuilder {
    /// Creates the builder to build the board at the beginning of the game.
    ///
    /// # Examples
    /// ```rust
    /// use tokyodoves::{Board, BoardBuilder};
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let board0 = Board::new();
    /// let board1 = BoardBuilder::new().build()?;
    /// let board2 = BoardBuilder::default().build()?;
    /// assert_eq!(board0, board1);
    /// assert_eq!(board0, board2);
    /// # Ok(())
    /// # }
    /// ```
    pub fn new() -> Self {
        Self::from_u64_bits([[1 << 8, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0]])
    }

    /// Creates the builder to build the empty board.
    ///
    /// It fails to build unless the status is editted.
    ///
    /// # Examples
    /// ```rust
    /// use tokyodoves::{Board, BoardBuilder, Color, Dove};
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut builder = BoardBuilder::empty();
    /// assert!(builder.build().is_err());
    /// builder
    ///     .put_dove(0, 0, Color::Green, Dove::B)
    ///     .put_dove(1, 0, Color::Red, Dove::B);
    /// let board = builder.build()?;
    /// assert_eq!(board, Board::new());
    /// # Ok(())
    /// # }
    /// ```
    pub fn empty() -> Self {
        Self::from_u64_bits([[0; 6]; 2])
    }

    /// Creates `BoardBuilder` by indicating positions of doves in `u64` directly.
    ///
    /// It is faster than [`from_u16_bits`](`Self::from_u16_bits`),
    /// but it does not ensure that all doves are included in the 4x4 region.
    ///
    /// # Examples
    /// ```rust
    /// use tokyodoves::{Board, BoardBuilder};
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let builder = BoardBuilder::from_u64_bits([[256, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0]]);
    /// let board = builder.build()?;
    /// assert_eq!(board, Board::new());
    /// # Ok(())
    /// # }
    /// ```
    pub fn from_u64_bits(positions: [[u64; 6]; 2]) -> Self {
        Self::from(positions)
    }

    /// Creates `BoardBuilder` by indicating positions of doves in `u16` directly.
    ///
    /// It ensures that all doves are included in the 4x4 region,
    /// in the cost of conversion from `u16` to `u64`.
    ///
    /// # Examples
    /// ```rust
    /// use tokyodoves::{Board, BoardBuilder};
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let builder = BoardBuilder::from_u16_bits([[16, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0]]);
    /// let board = builder.build()?;
    /// assert_eq!(board, Board::new());
    /// # Ok(())
    /// # }
    /// ```
    /// assert_eq!(board, Board::new());
    pub fn from_u16_bits(positions: [[u16; 6]; 2]) -> Self {
        Self::from(positions)
    }

    /// Creates `BoardBuilder` from 4x4 matrix of doves, i.e., `[[Option<(Color, Dove)>; 4]; 4]`.
    ///
    /// # Errors
    /// It returns `Err` if the same dove (the same [`Color`] and [`Dove`]) is included in the matrix.
    ///
    /// # Examples
    /// ```rust
    /// use tokyodoves::{Board, BoardBuilder, Color, Dove};
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let matrix = [
    ///     [Some((Color::Green, Dove::B)), None, None, None],
    ///     [Some((Color::Red, Dove::B)), None, None, None],
    ///     [None, None, None, None],
    ///     [None, None, None, None],
    /// ];
    /// let builder = BoardBuilder::try_from_4x4_matrix(matrix)?;
    /// // Equivalent:
    /// // let builder = BoardBuilder::try_from(matrix)?;
    /// let board = builder.build()?;
    /// assert_eq!(board, Board::new());
    /// # Ok(())
    /// # }
    /// ```
    pub fn try_from_4x4_matrix(
        matrix: [[Option<(Color, Dove)>; 4]; 4],
    ) -> Result<Self, error::Error> {
        Self::try_from(matrix)
    }

    /// Creates `BoardBuilder` from `u64` expression of [`Board`].
    ///
    /// See the documentation of the method [`to_u64`](`Board::to_u64`) on [`Board`]
    /// for the definition of `u64` expression.
    /// ```rust
    /// use tokyodoves::{Board, BoardBuilder};
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let hash = 864761497199312896u64; // Board at the begining
    /// let builder = BoardBuilder::from_u64(hash);
    /// // Equivalent:
    /// // let builder = BoardBuilder::from(hash);
    /// let board = builder.build()?;
    /// assert_eq!(board, Board::new());
    /// # Ok(())
    /// # }
    /// ```
    pub fn from_u64(hash: u64) -> Self {
        Self::from(hash)
    }

    fn position(&self, color: Color, dove: Dove) -> &u64 {
        let icolor = color_to_index(color);
        let idove = dove_to_index(dove);
        // safety is guaranteed because icolor is in 0..2 and idove is in 0..6
        unsafe { self.positions.get_unchecked(icolor).get_unchecked(idove) }
    }

    /// Puts `dove` of the player in `color` on the specified position.
    ///
    /// A position is specified by two arguments `pos_v` and `pos_h`.
    /// The following diagram shows how the square is identified by two values.
    /// ```text
    ///   h 0   1   2   3
    /// v +---+---+---+---+
    /// 0 |   |   |   |   |
    ///   +---+---+---+---+
    /// 1 |   |   | * |   |
    ///   +---+---+---+---+
    /// 2 |   |   |   |   |
    ///   +---+---+---+---+
    /// 3 |   |   |   |   |
    ///   +---+---+---+---+
    /// ```
    /// For example, the square `*` is specified by `pos_v`=1 and `pos_h`=2.
    ///
    /// If both `pos_v` and `pos_h` are from 0 to 3, `color`'s `dove` is put on that position.
    /// If the dove has already exist on the board, it moves to the specified position.
    /// If either of `pos_v` or `pos_h` is greater than 3, nothing is changed.
    ///
    /// # Examples
    /// ```rust
    /// use tokyodoves::{Board, BoardBuilder, Color, Dove};
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut builder = BoardBuilder::new();
    /// builder.put_dove(2, 1, Color::Red, Dove::A);
    /// let board = builder.build()?;
    /// let ans = BoardBuilder::try_from_4x4_matrix([
    ///     [Some((Color::Green, Dove::B)), None, None, None],
    ///     [Some((Color::Red, Dove::B)), None, None, None],
    ///     [None, Some((Color::Red, Dove::A)), None, None],
    ///     [None, None, None, None],
    /// ])?.build()?;
    /// assert_eq!(board, ans);
    /// # Ok(())
    /// # }
    /// ```
    pub fn put_dove(&mut self, pos_v: usize, pos_h: usize, color: Color, dove: Dove) -> &mut Self {
        if pos_v < 4 && pos_h < 4 {
            let pos = 1 << (pos_h + 8 * pos_v);
            let icolor = color_to_index(color);
            let idove = dove_to_index(dove);
            // safety is guaranteed because icolor is in 0..2 and idove is in 0..6
            unsafe {
                *self
                    .positions
                    .get_unchecked_mut(icolor)
                    .get_unchecked_mut(idove) = pos;
            }
        }
        self
    }

    /// Removes `dove` of the player in `color`.
    ///
    /// # Examples
    /// ```rust
    /// use std::str::FromStr;
    /// use tokyodoves::{Board, BoardBuilder, Color, Dove};
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut builder = BoardBuilder::from_str("bT;B")?;
    /// builder.remove_dove(Color::Red, Dove::T);
    /// let board = builder.build()?;
    /// assert_eq!(board, Board::new());
    /// # Ok(())
    /// # }
    /// ```
    pub fn remove_dove(&mut self, color: Color, dove: Dove) -> &mut Self {
        let icolor = color_to_index(color);
        let idove = dove_to_index(dove);
        // safety is guaranteed because icolor is in 0..2 and idove is in 0..6
        unsafe {
            *self
                .positions
                .get_unchecked_mut(icolor)
                .get_unchecked_mut(idove) = 0;
        }
        self
    }

    /// Removes doves outside 4x4 field.
    ///
    /// # Examples
    /// ```rust
    /// use std::str::FromStr;
    /// use tokyodoves::{Board, BoardBuilder};
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let bits = [[256, 16, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0]];
    /// let mut builder = BoardBuilder::from_u64_bits(bits);
    /// // The above builder corresponds to the below:
    /// // +---+---+---+---+
    /// // | b |   |   |   | A
    /// // +---+---+---+---+
    /// // | B |   |   |   |
    /// // +---+---+---+---+
    /// // |   |   |   |   |
    /// // +---+---+---+---+
    /// // |   |   |   |   |
    /// // +---+---+---+---+
    /// // "A" is outside of 4x4 matrix.
    /// assert!(builder.build().is_err());
    /// builder.trim_outside_4x4(); // "A" is trimmed (removed)
    /// let board = builder.build()?;
    /// assert_eq!(board, Board::new());
    /// # Ok(())
    /// # }
    /// ```
    pub fn trim_outside_4x4(&mut self) -> &mut Self {
        let core = 0x0f0f0f0f;
        for icolor in 0..2 {
            for idove in 0..6 {
                // safety is guaranteed because icolor is in 0..2 and idove is in 0..6
                unsafe {
                    *self
                        .positions
                        .get_unchecked_mut(icolor)
                        .get_unchecked_mut(idove) &= core;
                }
            }
        }
        self
    }

    pub fn build_unchecked(&self) -> Board {
        let viewer = MaskViewer::new();
        let positions = ColorDovePositions::new([
            DovePositions::new(self.positions[0]),
            DovePositions::new(self.positions[1]),
        ]);
        Board::from_components(viewer, positions)
    }

    pub fn build(&self) -> Result<Board, error::Error> {
        use error::BoardCreateErrorKind::*;

        if self.positions[0][0] == 0 || self.positions[1][0] == 0 {
            return Err(BossNotFound.into());
        }
        let core = 0x0f0f0f0f;
        let mut bit_sum = 0;
        for colored_positions in self.positions {
            for bit in colored_positions {
                if bit & bit_sum != 0 {
                    return Err(PositionDuplicated.into());
                }
                if bit & core != bit {
                    return Err(PositionOutOfRange.into());
                }
                bit_sum |= bit;
            }
        }
        let board = self.build_unchecked();
        if board.positions.isolated() {
            return Err(DoveIsolated.into());
        }
        Ok(board)
    }
}

impl From<[[u64; 6]; 2]> for BoardBuilder {
    fn from(bits: [[u64; 6]; 2]) -> Self {
        Self { positions: bits }
    }
}

impl From<[[u16; 6]; 2]> for BoardBuilder {
    fn from(bits: [[u16; 6]; 2]) -> Self {
        fn extend_u16_to_u64(x: u16) -> u64 {
            let mut x_u64 = 0;
            x_u64 |= (x & 0xf) as u64;
            x_u64 |= ((x & 0xf0) as u64) << 4;
            x_u64 |= ((x & 0xf00) as u64) << 8;
            x_u64 |= ((x & 0xf000) as u64) << 12;
            x_u64
        }

        let mut bits_u64 = [[0; 6]; 2];
        for icolor in 0..2 {
            for idove in 0..6 {
                bits_u64[icolor][idove] = extend_u16_to_u64(bits[icolor][idove]);
            }
        }
        Self::from(bits_u64)
    }
}

impl TryFrom<[[Option<(Color, Dove)>; 4]; 4]> for BoardBuilder {
    type Error = error::Error;
    fn try_from(matrix: [[Option<(Color, Dove)>; 4]; 4]) -> Result<Self, Self::Error> {
        use error::BoardCreateErrorKind::*;

        let mut builder = BoardBuilder::empty();
        for (iv, line) in matrix.iter().enumerate() {
            for (ih, elem) in line.iter().enumerate() {
                if let Some((c, d)) = elem {
                    let pos = builder.position(*c, *d);
                    if *pos != 0 {
                        return Err(DoveDuplicated.into());
                    }
                    builder.put_dove(iv, ih, *c, *d);
                }
            }
        }
        Ok(builder)
    }
}

impl From<u64> for BoardBuilder {
    fn from(hash: u64) -> Self {
        let mut builder = BoardBuilder::empty();
        let mut onoff_mask = 1_u64 << 59;
        let mut pos_mask = 0xf_u64 << 44;

        for d in Dove::iter() {
            let id = dove_to_index(d);
            for c in Color::iter() {
                let ic = color_to_index(c);
                let ishift = 11 - (2 * id + ic);
                if onoff_mask & hash != 0 {
                    let ipos = ((hash & pos_mask) >> (4 * ishift)) as usize;
                    let pos_v = ipos / 4;
                    let pos_h = ipos % 4;
                    builder.put_dove(pos_v, pos_h, c, d);
                }
                onoff_mask >>= 1;
                pos_mask >>= 4;
            }
        }

        builder
    }
}

impl FromStr for BoardBuilder {
    type Err = error::Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        use error::BoardCreateErrorKind::*;

        let mut builder = BoardBuilder::empty();
        let mut pos_v = 0;
        let mut pos_h = 0;

        let delimiter = ';';
        for c in s.chars() {
            if c == delimiter {
                pos_h = 0;
                pos_v += 1;
                continue;
            }

            if let Some((color, dove)) = try_char_to_color_dove(c) {
                if *builder.position(color, dove) != 0 {
                    return Err(DoveDuplicated.into());
                }

                builder.put_dove(pos_v, pos_h, color, dove);
            }
            pos_h += 1;
        }
        Ok(builder)
    }
}
